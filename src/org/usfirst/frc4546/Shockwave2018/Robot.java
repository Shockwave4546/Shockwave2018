// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4546.Shockwave2018;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.PowerDistributionPanel;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.TimedRobot;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.VictorSP;
import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj.GenericHID.Hand;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the TimedRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the build.properties file in 
 * the project.
 */
public class Robot extends TimedRobot {

    Command autonomousCommand;
    SendableChooser<Command> chooser = new SendableChooser<>();
    
    private static final int kPDP = 0;
    private PowerDistributionPanel m_PDP;
    
    
    String gameData;
    
    
    
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
  

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    private static final int kMotorPort1 = 1;//Motor Controller 4
	private SpeedController FrontLeft;
	private double FrontLeftPos = .5;
	private double FrontLeftNeg = .5;
	private double FinalFrontLeft;
	
	private static final int kMotorPort3 = 3;//Motor Controller 6
	private SpeedController FrontRight;
	private double FrontRightPos = .5;
	private double FrontRightNeg = .5;
	private double FinalFrontRight;
	
	private static final int kMotorPort4= 4;//Motor Controller 2
	private SpeedController BackLeft;
	private double BackLeftPos = .5;
	private double BackLeftNeg = .5;
	private double FinalBackLeft;
	
	private static final int kMotorPort5 = 5;//Motor Controller 3
	private SpeedController BackRight;
	private double BackRightPos = .5;
	private double BackRightNeg = .5;
	private double FinalBackRight;
	
	private static final int kIntakePort2 = 2; //Motor Controller 10
	private SpeedController IntakeLeft;
	private double IntakeLeftPos = .5;
	private double IntakeLeftNeg = .5;
	private double FinalIntakeLeft;
	
	private static final int kIntakePort7 = 7; //Motor Controller 7
	private SpeedController IntakeRight;
	private double IntakeRightPos = .5;
	private double IntakeRightNeg = .5;
	private double FinalIntakeRight;
	
	private static final int kArmPort6 = 6;//Motor Controller 3
	private SpeedController ArmMotor;
	private double ArmPos = .5;
	private double ArmNeg = .5;
	private double FinalArm;
	
	private static final int kSlidePort8 = 8;//Motor Controller 1
	private SpeedController SlideMotor;
	private double SlidePos = .5;
	private double SlideNeg = .5;
	private double FinalSlide;
	

	public static Joystick Joystick;
	private double YAxis;
	private double Twist;
	private boolean Trigger;
	private double Slider;
	private boolean Button;
    
	public static XboxController Xbox;
    private double LeftY2;
    private double RightY2;
    

	private double auto = 0.5;
	private double delay1 = 0.1;
	private double delay2 = 0.2;
	private double delay3 = 0.3;
	private double delay4 = 0.4;
	private double delay5 = 0.5;
	private double delay6 = 0.6;
	private double delay7 = 0.7;
	private double delay8 = 0.8;
	private double delay9 = 0.9;
	private double delay0 = 1;
	//private static final int kMotorPort9 = 9;
	//private SpeedController speedController9;


    /**
     * This function is run when the robot is first started up and should be
     * used for any initialization code.
     */
    @Override
    public void robotInit() {
    	
    	m_PDP = new PowerDistributionPanel(kPDP);
    	SmartDashboard.putData("Voltage/Current", m_PDP);
    	SmartDashboard.putNumber("Power", m_PDP.getTotalPower());
    	SmartDashboard.putNumber("Total", m_PDP.getTotalPower() * Timer.getMatchTime());
    	
    	FrontLeft = new Talon(kMotorPort1);
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
     

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // OI must be constructed after subsystems. If the OI creates Commands
        //(which it very likely will), subsystems are not guaranteed to be
        // constructed yet. Thus, their requires() statements may grab null
        // pointers. Bad news. Don't move it.
    

        // Add commands to Autonomous Sendable Chooser
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS



    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

    	FrontLeft = new VictorSP(kMotorPort1);
    	FrontLeft.setInverted(false);
    	
    	FrontRight = new Talon(kMotorPort3);
    	FrontRight.setInverted(true);
    	
    	BackLeft = new Talon(kMotorPort4);
    	BackLeft.setInverted(false);
    	
    	BackRight = new Talon(kMotorPort5);
    	BackRight.setInverted(true);
    	
    	IntakeLeft = new Talon(kIntakePort2);//Victor SPX
    	IntakeLeft.setInverted(false);
    	
    	IntakeRight = new Talon(kIntakePort7);//Victor SPX
    	IntakeRight.setInverted(true);
    	
     	ArmMotor = new Talon(kArmPort6);
     	ArmMotor.setInverted(false);
     	
    	SlideMotor = new Talon(kSlidePort8);
    	SlideMotor.setInverted(false);
    	
    	Joystick = new Joystick(0);
    	Xbox = new XboxController(1);
    	
    	//speedController9 = new VictorSP(kMotorPort9);
        

        SmartDashboard.putData("Auto mode", chooser);
    }

    /**
     * This function is called when the disabled button is hit.
     * You can use it to reset subsystems before shutting down.
     */
    @Override
    public void disabledInit(){

    }

    @Override
    public void disabledPeriodic() {
        Scheduler.getInstance().run();
    }

    @Override
    public void autonomousInit() {
        autonomousCommand = chooser.getSelected();
        // schedule the autonomous command (example)
        if (autonomousCommand != null) autonomousCommand.start();
    }

    /**
     * This function is called periodically during autonomous  
     */
    @Override
    public void autonomousPeriodic() {
        Scheduler.getInstance().run();
   	gameData = DriverStation.getInstance().getGameSpecificMessage();
    	
    	if(gameData.length() > 0){
    		if(gameData.charAt(0) == 'L'){
    			FrontRight.set(auto);
    			FrontLeft.set(auto);
    			BackRight.set(auto);
    			BackLeft.set(auto);
    			Timer.delay(delay0);
    			FrontRight.set(-auto);
    			FrontLeft.set(auto);
    			BackRight.set(-auto);
    			BackLeft.set(auto);
    			Timer.delay(delay1);
    			ArmMotor.set(1);
    			Timer.delay(delay5);
    			IntakeLeft.set(auto);
    			IntakeRight.set(auto);
    		}else{
    			FrontRight.set(auto);
    			FrontLeft.set(auto);
    			BackRight.set(auto);
    			BackLeft.set(auto);
    			Timer.delay(delay0*2);
    			FrontRight.set(-auto);
    			FrontLeft.set(auto);
    			BackRight.set(-auto);
    			BackLeft.set(auto);
    			Timer.delay(delay1);
    			FrontRight.set(auto);
    			FrontLeft.set(auto);
    			BackRight.set(auto);
    			BackLeft.set(auto);
    			Timer.delay(delay0*4);
    			FrontRight.set(-auto);
    			FrontLeft.set(auto);
    			BackRight.set(-auto);
    			BackLeft.set(auto);
    			Timer.delay(delay1);
    			FrontRight.set(auto);
    			FrontLeft.set(auto);
    			BackRight.set(auto);
    			BackLeft.set(auto);
    			Timer.delay(delay5);
    			FrontRight.set(-auto);
    			FrontLeft.set(auto);
    			BackRight.set(-auto);
    			BackLeft.set(auto);
    			Timer.delay(delay1);
    			ArmMotor.set(1);
    			Timer.delay(delay5);
    			IntakeLeft.set(auto);
    			IntakeRight.set(auto);}
    }
   }
    @Override
    public void teleopInit() {
        if (autonomousCommand != null) autonomousCommand.cancel();
    }

    /**
     * This function is called periodically during operator control
     */
    @Override
    public void teleopPeriodic() {
        Scheduler.getInstance().run();
    	LeftY2 = Xbox.getY(Hand.kLeft);
    	RightY2 = Xbox.getY(Hand.kRight);
    	YAxis = Joystick.getY();
    	Twist = Joystick.getTwist();
    	Slider = (-(Joystick.getThrottle()-1)/2);
    	Trigger = Joystick.getTrigger();
    	Button = Joystick.getTop();
    
    	if(Button==false && Trigger==false){
        	IntakeLeft.set(0);
        	FinalIntakeLeft = 0;
        	IntakeRight.set(0);
        	FinalIntakeRight = 0;
        }else if(Button==true && Trigger==false){
        	IntakeLeft.set(IntakeLeftPos);
        	FinalIntakeLeft = (IntakeLeftPos);
        	IntakeRight.set(-IntakeRightNeg);
        	FinalIntakeRight = (-IntakeRightNeg);
        }else if(Button==false && Trigger==true){
        	IntakeLeft.set(-IntakeLeftNeg);
        	FinalIntakeLeft = (-IntakeLeftNeg);
        	IntakeRight.set(IntakeRightPos);
        	FinalIntakeRight = (IntakeRightPos);
        }//intake motors
        
        
        if(LeftY2<.1 && LeftY2>-.1){
        	SlideMotor.set(0);
        	FinalSlide = 0;
        }else if(LeftY2<.1 && LeftY2<=-.1){
        	SlideMotor.set(LeftY2*SlideNeg);
        	FinalSlide = (LeftY2*SlideNeg);
        }else if(LeftY2>=.1 && LeftY2>-.1){
        	SlideMotor.set(LeftY2*SlidePos);
        	FinalSlide = (LeftY2*SlidePos);
        }//Slide motor
        
        if(RightY2<.1 && RightY2>-.1){
        	ArmMotor.set(0);
        	FinalArm = 0;
        }else if(RightY2<.1 && RightY2<=-.1){
        	ArmMotor.set(RightY2*ArmNeg);
        	FinalArm = (RightY2*ArmNeg);
        }else if(RightY2>=.1 && RightY2>-.1){
        	ArmMotor.set(RightY2*ArmPos);
        	FinalArm = (RightY2*ArmPos);
        }//Arm motor
        
        
        if(YAxis<=.1 && YAxis>=-.1 && Twist<=.1 && Twist>=-.1){
        	FrontLeft.set(0);
        	FinalFrontLeft = (0);
        	BackLeft.set(0);
        	FinalBackLeft = (0);
        	FrontRight.set(0);
        	FinalFrontRight = (0);
        	BackRight.set(0);
        	FinalFrontRight = (0);
        	//Idle
        }else if(YAxis>.1 && Twist<=.1 && Twist>=-.1){
        	FrontLeft.set((YAxis*FrontLeftNeg)*Slider);
        	FinalFrontLeft = ((YAxis*FrontLeftNeg)*Slider);
        	BackLeft.set((YAxis*BackLeftNeg)*Slider);
        	FinalBackLeft = ((YAxis*BackLeftNeg)*Slider);
        	FrontRight.set((YAxis*FrontRightNeg)*Slider);
        	FinalFrontRight = ((YAxis*FrontRightNeg)*Slider);
        	BackRight.set((YAxis*BackRightNeg)*Slider);
        	FinalFrontRight = ((YAxis*BackRightNeg)*Slider);
        	//Motor Back
        }else if(YAxis<-.1 && Twist<=.1 && Twist>=-.1){
        	FrontLeft.set((YAxis*FrontLeftPos)*Slider);
        	FinalFrontLeft = ((YAxis*FrontLeftPos)*Slider);
        	BackLeft.set((YAxis*BackLeftPos)*Slider);
        	FinalBackLeft = ((YAxis*BackLeftPos)*Slider);
        	FrontRight.set((YAxis*FrontRightPos)*Slider);
        	FinalFrontRight = ((YAxis*FrontRightPos)*Slider);
        	BackRight.set((YAxis*BackRightPos)*Slider);
        	FinalFrontRight = ((YAxis*BackRightPos)*Slider);
        	//Motor Forward
        }else if(YAxis<-.1 && Twist>.1){
        	FrontLeft.set((YAxis*FrontLeftPos)*Slider);
        	FinalFrontLeft = ((YAxis*FrontLeftPos)*Slider);
        	BackLeft.set((YAxis*BackLeftPos)*Slider);
        	FinalBackLeft = ((YAxis*BackLeftPos)*Slider);
        	FrontRight.set(((YAxis*FrontLeftPos)*Slider)*(Twist*FrontLeftPos));
        	FinalFrontRight = (((YAxis*FrontLeftPos)*Slider)*(Twist*FrontLeftPos));
        	BackRight.set(((YAxis*BackLeftPos)*Slider)*(Twist*BackLeftPos));
        	FinalFrontRight = (((YAxis*BackLeftPos)*Slider)*(Twist*BackLeftPos));
        	//Forward Right
        }else if(YAxis<-.1 && Twist<-.1){
        	FrontLeft.set(((YAxis*FrontLeftPos)*Slider)*(Twist*-FrontLeftPos));
        	FinalFrontLeft = (((YAxis*FrontLeftPos)*Slider)*(Twist*-FrontLeftPos));
        	BackLeft.set(((YAxis*BackLeftPos)*Slider)*(Twist*-FrontLeftPos));
        	FinalBackLeft = (((YAxis*BackLeftPos)*Slider)*(Twist*-FrontLeftPos));
        	FrontRight.set((YAxis*FrontRightPos)*Slider);
        	FinalFrontRight = ((YAxis*FrontRightPos)*Slider);
        	BackRight.set((YAxis*BackRightPos)*Slider);
        	FinalFrontRight = ((YAxis*BackRightPos)*Slider);
        	//Forward Left
        }else if(YAxis>.1 && Twist>.1){
        	FrontLeft.set((YAxis*FrontLeftPos)*Slider);
        	FinalFrontLeft = ((YAxis*FrontLeftPos)*Slider);
        	BackLeft.set((YAxis*BackLeftPos)*Slider);
        	FinalBackLeft = ((YAxis*BackLeftPos)*Slider);
        	FrontRight.set(((YAxis*FrontLeftPos)*Slider)*(Twist*FrontLeftPos));
        	FinalFrontRight = (((YAxis*FrontLeftPos)*Slider)*(Twist*FrontLeftPos));
        	BackRight.set(((YAxis*BackLeftPos)*Slider)*(Twist*BackLeftPos));
        	FinalFrontRight = (((YAxis*BackLeftPos)*Slider)*(Twist*BackLeftPos));
        	//Back Right
        }else if(YAxis>.1 && Twist<-.1){
        	FrontLeft.set(((YAxis*FrontLeftPos)*Slider)*(Twist*-FrontLeftPos));
        	FinalFrontLeft = (((YAxis*FrontLeftPos)*Slider)*(Twist*-FrontLeftPos));
        	BackLeft.set(((YAxis*BackLeftPos)*Slider)*(Twist*-FrontLeftPos));
        	FinalBackLeft = (((YAxis*BackLeftPos)*Slider)*(Twist*-FrontLeftPos));
        	FrontRight.set((YAxis*FrontRightPos)*Slider);
        	FinalFrontRight = ((YAxis*FrontRightPos)*Slider);
        	BackRight.set((YAxis*BackRightPos)*Slider);
        	FinalFrontRight = ((YAxis*BackRightPos)*Slider);
        	//Back Left
        }else if(YAxis<=.1 && YAxis>=-.1 && Twist<-.1){
        	FrontLeft.set((Twist*FrontLeftNeg)*Slider);
        	FinalFrontLeft = ((Twist*FrontLeftNeg)*Slider);
        	BackLeft.set((Twist*BackLeftNeg)*Slider);
        	FinalBackLeft = ((Twist*BackLeftNeg)*Slider);
        	FrontRight.set((Twist*FrontRightPos)*-Slider);
        	FinalFrontRight = ((Twist*FrontRightPos)*-Slider);
        	BackRight.set((Twist*BackRightPos)*-Slider);
        	FinalFrontRight = ((Twist*BackRightPos)*-Slider);
        	//Spin Left
        }else if(YAxis<=.1 && YAxis>=-.1 && Twist>.1){
        	FrontLeft.set((Twist*FrontLeftPos)*Slider);
        	FinalFrontLeft = ((Twist*FrontLeftPos)*Slider);
        	BackLeft.set((Twist*BackLeftPos)*Slider);
        	FinalBackLeft = ((Twist*BackLeftPos)*Slider);
        	FrontRight.set((Twist*FrontRightNeg)*-Slider);
        	FinalFrontRight = ((Twist*FrontRightNeg)*-Slider);
        	BackRight.set((Twist*BackRightNeg)*-Slider);
        	FinalFrontRight = ((Twist*BackRightNeg)*-Slider);
        	//Spin Right
        }      
    }
}
