// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4546.Shockwave2018;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.PowerDistributionPanel;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.TimedRobot;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.VictorSP;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the TimedRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the build.properties file in 
 * the project.
 */
public class Robot extends TimedRobot {

    Command autonomousCommand;
    SendableChooser<Command> chooser = new SendableChooser<>();
    
    private static final int kPDP = 0;
    private PowerDistributionPanel m_PDP;
    
    
    String gameData;
    
    
    
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
  

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    private static final int kMotorPort1 = 1;//Motor Controller 4
	private SpeedController FrontLeft;
	private double FrontLeftPos = .5;
	private double FrontLeftNeg = .5;
	
	private static final int kMotorPort3 = 3;//Motor Controller 6
	private SpeedController FrontRight;
	private double  FrontRightPos = .5;
	private double  FrontRightNeg = .5;
	
	private static final int kMotorPort4= 4;//Motor Controller 2
	private SpeedController BackLeft;
	private double  BackLeftPos = .5;
	private double  BackLeftNeg = .5;
	
	private static final int kMotorPort5 = 5;//Motor Controller 3
	private SpeedController BackRight;
	private double  BackRightPos = .5;
	private double  BackRightNeg = .5;
	
	private static final int kIntakePort2 = 2; //Motor Controller 10
	private SpeedController IntakeLeft;
	private double  IntakeLeftPos = .5;
	private double  IntakeLeftNeg = .5;
	
	private static final int kIntakePort7 = 7; //Motor Controller 7
	private SpeedController IntakeRight;
	private double  IntakeRightPos = .5;
	private double  IntakeRightNeg = .5;
	
	private static final int kArmPort6 = 6;//Motor Controller 3
	private SpeedController ArmMotor;
	private double  ArmPos = .5;
	private double  ArmNeg = .5;
	
	private static final int kSlidePort8 = 8;//Motor Controller 1
	private SpeedController SlideMotor;
	private double  SlidePos = .5;
	private double  SlideNeg = .5;
	
	private double auto = 0.5;
	private double delay1 = 0.1;
	private double delay2 = 0.2;
	private double delay3 = 0.3;
	private double delay4 = 0.4;
	private double delay5 = 0.5;
	private double delay6 = 0.6;
	private double delay7 = 0.7;
	private double delay8 = 0.8;
	private double delay9 = 0.9;
	private double delay0 = 1;
	//private static final int kMotorPort9 = 9;
	//private SpeedController speedController9;


    /**
     * This function is run when the robot is first started up and should be
     * used for any initialization code.
     */
    @Override
    public void robotInit() {
    	
    	m_PDP = new PowerDistributionPanel(kPDP);
    	SmartDashboard.putData("Voltage/Current", m_PDP);
    	SmartDashboard.putNumber("Power", m_PDP.getTotalPower());
    	SmartDashboard.putNumber("Total", m_PDP.getTotalPower() * Timer.getMatchTime());
    	
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
     

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // OI must be constructed after subsystems. If the OI creates Commands
        //(which it very likely will), subsystems are not guaranteed to be
        // constructed yet. Thus, their requires() statements may grab null
        // pointers. Bad news. Don't move it.
    

        // Add commands to Autonomous Sendable Chooser
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS



    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

    	FrontLeft = new VictorSP(kMotorPort1);
    	FrontLeft.setInverted(false);
    	
    	FrontRight = new VictorSP(kMotorPort3);
    	FrontRight.setInverted(false);
    	
    	BackLeft = new VictorSP(kMotorPort4);
    	BackLeft.setInverted(false);
    	
    	BackRight = new VictorSP(kMotorPort5);
    	BackRight.setInverted(false);
    	
    	IntakeLeft = new VictorSP(kIntakePort2);//Victor SPX
    	IntakeLeft.setInverted(false);
    	
    	IntakeRight = new VictorSP(kIntakePort7);//Victor SPX
    	IntakeRight.setInverted(false);
    	
     	ArmMotor = new VictorSP(kArmPort6);
     	ArmMotor.setInverted(false);
     	
    	SlideMotor = new VictorSP(kSlidePort8);
    	SlideMotor.setInverted(false);
    	
    	//speedController9 = new VictorSP(kMotorPort9);
        

        SmartDashboard.putData("Auto mode", chooser);
    }

    /**
     * This function is called when the disabled button is hit.
     * You can use it to reset subsystems before shutting down.
     */
    @Override
    public void disabledInit(){

    }

    @Override
    public void disabledPeriodic() {
        Scheduler.getInstance().run();
    }

    @Override
    public void autonomousInit() {
        autonomousCommand = chooser.getSelected();
        // schedule the autonomous command (example)
        if (autonomousCommand != null) autonomousCommand.start();
    }

    /**
     * This function is called periodically during autonomous  
     */
    @Override
    public void autonomousPeriodic() {
        Scheduler.getInstance().run();
   	gameData = DriverStation.getInstance().getGameSpecificMessage();
    	
    	if(gameData.length() > 0){
    		if(gameData.charAt(0) == 'L'){
    			FrontRight.set(auto);
    			FrontLeft.set(auto);
    			BackRight.set(auto);
    			BackLeft.set(auto);
    			Timer.delay(delay0);
    			FrontRight.set(-auto);
    			FrontLeft.set(auto);
    			BackRight.set(-auto);
    			BackLeft.set(auto);
    			Timer.delay(delay1);
    			ArmMotor.set(1);
    			Timer.delay(delay5);
    			IntakeLeft.set(auto);
    			IntakeRight.set(auto);
    		}else{
    			FrontRight.set(auto);
    			FrontLeft.set(auto);
    			BackRight.set(auto);
    			BackLeft.set(auto);
    			Timer.delay(delay0*2);
    			FrontRight.set(-auto);
    			FrontLeft.set(auto);
    			BackRight.set(-auto);
    			BackLeft.set(auto);
    			Timer.delay(delay1);
    			FrontRight.set(auto);
    			FrontLeft.set(auto);
    			BackRight.set(auto);
    			BackLeft.set(auto);
    			Timer.delay(delay0*4);
    			FrontRight.set(-auto);
    			FrontLeft.set(auto);
    			BackRight.set(-auto);
    			BackLeft.set(auto);
    			Timer.delay(delay1);
    			FrontRight.set(auto);
    			FrontLeft.set(auto);
    			BackRight.set(auto);
    			BackLeft.set(auto);
    			Timer.delay(delay5);
    			FrontRight.set(-auto);
    			FrontLeft.set(auto);
    			BackRight.set(-auto);
    			BackLeft.set(auto);
    			Timer.delay(delay1);
    			ArmMotor.set(1);
    			Timer.delay(delay5);
    			IntakeLeft.set(auto);
    			IntakeRight.set(auto);}
    }
   }
    @Override
    public void teleopInit() {
        if (autonomousCommand != null) autonomousCommand.cancel();
    }

    /**
     * This function is called periodically during operator control
     */
    @Override
    public void teleopPeriodic() {
        Scheduler.getInstance().run();
        
    }
}
