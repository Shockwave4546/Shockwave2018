// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4546.Shockwave2018;

import org.opencv.core.Mat;
import org.opencv.imgproc.Imgproc;
import edu.wpi.cscore.CvSink;
import edu.wpi.cscore.CvSource;
import edu.wpi.cscore.UsbCamera;
import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.CameraServer;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.PowerDistributionPanel;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.TimedRobot;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.VictorSP;
import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj.GenericHID.Hand;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the TimedRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the build.properties file in 
 * the project.
 */
public class Robot extends TimedRobot {

    Command autonomousCommand;
    SendableChooser<Command> chooser = new SendableChooser<>();
    
    private static final int kPDP = 0;
	private AnalogInput ai;
   
	DigitalInput limitswitch;

    private PowerDistributionPanel m_PDP;    
    String gameData;

    
  
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
  

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    private static final int kMotorPort1 = 1;//Motor Controller 4
	private SpeedController FrontLeft;
	private double FrontLeftPos = .5;
	private double FrontLeftNeg = .5;
	private double FinalFrontLeft;
	
	private static final int kMotorPort3 = 3;//Motor Controller 6
	private SpeedController FrontRight;
	private double FrontRightPos = .5;
	private double FrontRightNeg = .5;
	private double FinalFrontRight;
	
	private static final int kMotorPort4= 4;//Motor Controller 2
	private SpeedController BackLeft;
	private double BackLeftPos = .5;
	private double BackLeftNeg = .5;
	private double FinalBackLeft;
	
	private static final int kMotorPort5 = 5;//Motor Controller 3
	private SpeedController BackRight;
	private double BackRightPos = .5;
	private double BackRightNeg = .5;
	private double FinalBackRight;
	
	private static final int kIntakePort2 = 2; //Motor Controller 10
	private SpeedController IntakeLeft;
	private double IntakeLeftPos = .5;
	private double IntakeLeftNeg = .5;
	private double FinalIntakeLeft;
	
	private static final int kIntakePort7 = 7; //Motor Controller 7
	private SpeedController IntakeRight;
	private double IntakeRightPos = .5;
	private double IntakeRightNeg = .5;
	private double FinalIntakeRight;
	
	private static final int kArmPort6 = 6;//Motor Controller 3
	private SpeedController ArmMotor;
	private double ArmPos = .5;
	private double ArmNeg = .5;
	private double FinalArm;
	
	private static final int kSlidePort8 = 8;//Motor Controller 1
	private SpeedController SlideMotor;
	private double SlidePos = .5;
	private double SlideNeg = .5;
	private double FinalSlide;
	
	public static Joystick Joystick;
	private double YAxis;
	private double Twist;
	private boolean Trigger;
	private double Slider;
	private boolean Button;
    
	public static XboxController Xbox;
    private double LeftY2;
    private double RightY2;
    
	private double auto = 0.5;
	private double delay1 = 0.1;
	private double delay2 = 0.2;
	private double delay3 = 0.3;
	private double delay4 = 0.4;
	private double delay5 = 0.5;
	private double delay6 = 0.6;
	private double delay7 = 0.7;
	private double delay8 = 0.8;
	private double delay9 = 0.9;
	private double delay0 = 1;
	//private static final int kMotorPort9 = 9;

	//private SpeedController speedController9;

	//private SpeedController speedController9;
	
	//Slider Variables
	double FLSlideVal;
	double FRSlideVal;
	double BLSlideVal;
	double BRSlideVal;
	double ILSlideVal;
	double IRSlideVal;
	double AMSlideVal;
	double SMSlideVal;
	
	
	
    /**
     * This function is run when the robot is first started up and should be
     * used for any initialization code.
     */
    @Override
    public void robotInit() {
    	
    	m_PDP = new PowerDistributionPanel(kPDP);
    	SmartDashboard.putData("Voltage/Current", m_PDP);
    	SmartDashboard.putNumber("Power", m_PDP.getTotalPower());
    	SmartDashboard.putNumber("Total", m_PDP.getTotalPower() * Timer.getMatchTime());
    	
    	ai = new AnalogInput(0);
    	
    	
        	limitswitch = new DigitalInput(1);
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
     

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // OI must be constructed after subsystems. If the OI creates Commands
        //(which it very likely will), subsystems are not guaranteed to be
        // constructed yet. Thus, their requires() statements may grab null
        // pointers. Bad news. Don't move it.
    

        // Add commands to Autonomous Sendable Chooser
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS



    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
    	SmartDashboard.putData("Auto mode", chooser);
        new Thread(() -> {
            UsbCamera camera = CameraServer.getInstance().startAutomaticCapture();
            camera.setResolution(640, 480);
            
            CvSink cvSink = CameraServer.getInstance().getVideo();
            CvSource outputStream = CameraServer.getInstance().putVideo("Blur", 640, 480);
            
            Mat source = new Mat();
            Mat output = new Mat();
            
            while(!Thread.interrupted()) {
                cvSink.grabFrame(source);
                Imgproc.cvtColor(source, output, Imgproc.COLOR_BGR2GRAY);
                outputStream.putFrame(output);
            }
        }).start();

    	SmartDashboard.putNumber("Total", m_PDP.getTotalPower() * Timer.getMatchTime());
    	
    	FrontLeft = new Talon(kMotorPort1);
    	FrontLeft.setInverted(false);
    	
    	FrontRight = new Talon(kMotorPort3);
    	FrontRight.setInverted(true);
    	
    	BackLeft = new Talon(kMotorPort4);
    	BackLeft.setInverted(false);
    	
    	BackRight = new Talon(kMotorPort5);
    	BackRight.setInverted(true);
    	
    	IntakeLeft = new Talon(kIntakePort2);//Victor SPX
    	IntakeLeft.setInverted(false);
    	
    	IntakeRight = new Talon(kIntakePort7);//Victor SPX
    	IntakeRight.setInverted(true);
    	
     	ArmMotor = new Talon(kArmPort6);
     	ArmMotor.setInverted(false);
     	
    	SlideMotor = new Talon(kSlidePort8);
    	SlideMotor.setInverted(false);
    	
    	//speedController9 = new VictorSP(kMotorPort9);
        

        SmartDashboard.putData("Auto mode", chooser);
    	Joystick = new Joystick(0);
    	Xbox = new XboxController(1);
    	
    	SmartDashboard.putData("Auto mode", chooser);
    }

    /**
     * This function is called when the disabled button is hit.
     * You can use it to reset subsystems before shutting down.
     */
    @Override
    public void disabledInit(){

    }

    @Override
    public void disabledPeriodic() {
        Scheduler.getInstance().run();
    }

    @Override
    public void autonomousInit() {
        autonomousCommand = chooser.getSelected();
        // schedule the autonomous command (example)
        if (autonomousCommand != null) autonomousCommand.start();
    }

    /**
     * This function is called periodically during autonomous  
     */
    @Override
    public void autonomousPeriodic() {
        Scheduler.getInstance().run();
   	gameData = DriverStation.getInstance().getGameSpecificMessage();
    	
    	if(gameData.length() > 0){
    		if(gameData.charAt(0) == 'L'){
    			FrontRight.set(auto);
    			FrontLeft.set(auto);
    			BackRight.set(auto);
    			BackLeft.set(auto);
    			Timer.delay(delay0);
    			FrontRight.set(-auto);
    			FrontLeft.set(auto);
    			BackRight.set(-auto);
    			BackLeft.set(auto);
    			Timer.delay(delay1);
    			ArmMotor.set(1);
    			Timer.delay(delay5);
    			IntakeLeft.set(auto);
    			IntakeRight.set(auto);
    		}else{
    			FrontRight.set(auto);
    			FrontLeft.set(auto);
    			BackRight.set(auto);
    			BackLeft.set(auto);
    			Timer.delay(delay0*2);
    			FrontRight.set(-auto);
    			FrontLeft.set(auto);
    			BackRight.set(-auto);
    			BackLeft.set(auto);
    			Timer.delay(delay1);
    			FrontRight.set(auto);
    			FrontLeft.set(auto);
    			BackRight.set(auto);
    			BackLeft.set(auto);
    			Timer.delay(delay0*4);
    			FrontRight.set(-auto);
    			FrontLeft.set(auto);
    			BackRight.set(-auto);
    			BackLeft.set(auto);
    			Timer.delay(delay1);
    			FrontRight.set(auto);
    			FrontLeft.set(auto);
    			BackRight.set(auto);
    			BackLeft.set(auto);
    			Timer.delay(delay5);
    			FrontRight.set(-auto);
    			FrontLeft.set(auto);
    			BackRight.set(-auto);
    			BackLeft.set(auto);
    			Timer.delay(delay1);
    			ArmMotor.set(1);
    			Timer.delay(delay5);
    			IntakeLeft.set(auto);
    			IntakeRight.set(auto);}
    }
   }
    @Override
    public void teleopInit() {
        if (autonomousCommand != null) autonomousCommand.cancel();
        
      //Inserts a blank textbox with true or false value (set to false first from Iterative function)
      		SmartDashboard.putBoolean("ToggleSliderControl",true);
      		
      //Inserts Slider for Each Individual Motor (Simulates the Joystick)
    		SmartDashboard.putNumber("FrontL_Slider",0);
    		SmartDashboard.putNumber("FrontR_Slider",0);
    		SmartDashboard.putNumber("BackL_Slider",0);
    		SmartDashboard.putNumber("BackR_Slider",0);
    		SmartDashboard.putNumber("IntakeL_Slider",0);
    		SmartDashboard.putNumber("IntakeR_Slider",0);
    		SmartDashboard.putNumber("Arm_Slider",0);
    		SmartDashboard.putNumber("SlideMotor_Slider",0);
    		
    	//Inserts Scaler Modifiers for Each Motor and their +/- on Shuffleboard (Number Input)
    		SmartDashboard.putNumber("+FL_Scale",FrontLeftPos);
    		SmartDashboard.putNumber("-FL_Scale",FrontLeftNeg);
    		SmartDashboard.putNumber("+FR_Scale",FrontRightPos);
    		SmartDashboard.putNumber("-FR_Scale",FrontRightNeg);
    		SmartDashboard.putNumber("+BL_Scale",BackLeftPos);
    		SmartDashboard.putNumber("-BL_Scale",BackLeftNeg);
    		SmartDashboard.putNumber("+BR_Scale",BackRightPos);
    		SmartDashboard.putNumber("-BR_Scale",BackRightNeg);
    		
    		SmartDashboard.putNumber("+IL_Scale",IntakeLeftPos);
    		SmartDashboard.putNumber("-IL_Scale",IntakeLeftNeg);
    		SmartDashboard.putNumber("+IR_Scale",IntakeRightPos);
    		SmartDashboard.putNumber("-IR_Scale",IntakeRightNeg);
    		SmartDashboard.putNumber("+AM_Scale",ArmPos);
    		SmartDashboard.putNumber("-AM_Scale",ArmNeg);
    		SmartDashboard.putNumber("+SM_Scale",SlidePos);
    		SmartDashboard.putNumber("-SM_Scale",SlideNeg);
    		
    	//Inserts Final Motor Value from (Slider/Joystick * Scaler)
  			SmartDashboard.putNumber("FLMotor",0);
  			SmartDashboard.putNumber("FRMotor",0);
  			SmartDashboard.putNumber("BLMotor",0);
  			SmartDashboard.putNumber("BRMotor",0);
  			
  			SmartDashboard.putNumber("ILMotor",0);
  			SmartDashboard.putNumber("IRMotor",0);
  			SmartDashboard.putNumber("AMMotor",0);
  			SmartDashboard.putNumber("SMMotor",0);
   
    		
    	//Intake Motor Direction Indicator is Inserted.
    		SmartDashboard.putString("LeftIntakeDirection", "Neutral");
    		SmartDashboard.putString("RightIntakeDirection", "Neutral");
    		
    	//Drive Direction Indicator is Inserted.
    		SmartDashboard.putString("Main Direction", "Idle");
    		SmartDashboard.putString("Turning", "None");
    }

    /**
     * This function is called periodically during operator control
     */
    @Override

    public void teleopPeriodic() {
        Scheduler.getInstance().run();
    
       /* if(ai.getValue() > 3500){
			ArmMotor.set(1);
		}
        if(ai.getValue() > 3000 && ai.getValue() < 3450){
			ArmMotor.set(0.5);
		}
		if(ai.getValue() < 2950 && ai.getValue() > 1450){
			ArmMotor.set(0.1);
		}
		if(ai.getValue() < 1000){
			ArmMotor.set(0);
		}
		if(limitswitch.get() == true){	
		}
    
    	AnalogInput.setGlobalSampleRate(62500);
		
		//Default value of samples per channel per second, causes all channels to sample at same rate
		
		AnalogInput exampleAnalog = new AnalogInput(0);
		int raw = exampleAnalog.getValue();
		double volts = exampleAnalog.getVoltage();
		int averageRaw = exampleAnalog.getAverageValue();
		double averageVolts = exampleAnalog.getAverageVoltage();
		
		
		 //-Raw value for bits without calibration
		 //-Volts value for bits after calibration
		
    
		SmartDashboard.putNumber("Analog Value", exampleAnalog.getValue());
		SmartDashboard.putNumber("Analog Voltage", exampleAnalog.getVoltage()); 
		
		//Just putting values on dashboard
		
		*/

 
        	//Toggle Button for Boolean on ShuffleBoard
      		boolean ToggleSliderValue = SmartDashboard.getBoolean("ToggleSliderControl", true);
      		
      		if(ai.getValue() > 3500){
    			ArmMotor.set(1);
    		}
            if(ai.getValue() > 3000 && ai.getValue() < 3450){
    			ArmMotor.set(0.5);
    		}
    		if(ai.getValue() < 2950 && ai.getValue() > 1450){
    			ArmMotor.set(0.1);
    		}
    		if(ai.getValue() < 1000){
    			ArmMotor.set(0);
    		}
    		if(limitswitch.get() == true){	
    		}
      		
    		SmartDashboard.putNumber("Analog Value", ai.getValue());
    		SmartDashboard.putNumber("Analog Voltage", ai.getVoltage());
      		
 //ShuffleBoard Control Code is below this line.     	
      	if(ToggleSliderValue == false) {
      		// Slider for the Left Motor and Right Motor (Gets value from slider)
      			FLSlideVal = SmartDashboard.getNumber("FrontL_Slider",0);
      			FRSlideVal = SmartDashboard.getNumber("FrontR_Slider",0);
      			BLSlideVal = SmartDashboard.getNumber("BackL_Slider",0);
      			BRSlideVal = SmartDashboard.getNumber("BackR_Slider",0);
      			
      			ILSlideVal = SmartDashboard.getNumber("IntakeL_Slider",0);
      			IRSlideVal = SmartDashboard.getNumber("IntakeR_Slider",0);
      			AMSlideVal = SmartDashboard.getNumber("Arm_Slider",0);
      			SMSlideVal = SmartDashboard.getNumber("SlideMotor_Slider",0);
      			
      		// Retrieves Scaler set for Drive Train Motors on ShuffleBoard
      			FrontLeftPos = SmartDashboard.getNumber("+FL_Scale",FrontLeftPos);
        		FrontLeftNeg = SmartDashboard.getNumber("-FL_Scale",FrontLeftNeg);
        		FrontRightPos = SmartDashboard.getNumber("+FR_Scale",FrontRightPos);
        		FrontRightNeg = SmartDashboard.getNumber("-FR_Scale",FrontRightNeg);
        		BackLeftPos = SmartDashboard.getNumber("+BL_Scale",BackLeftPos);
        		BackLeftNeg = SmartDashboard.getNumber("-BL_Scale",BackLeftNeg);
        		BackRightPos = SmartDashboard.getNumber("+BR_Scale",BackRightPos);
        		BackRightNeg = SmartDashboard.getNumber("-BR_Scale",BackRightNeg);
     		
        	//Retrieves Intake (Left & Right), Arm Motor, Slide Motor Scalers from ShuffleBoard.
        		IntakeLeftPos = SmartDashboard.getNumber("+IL_Scale",IntakeLeftPos);
        		IntakeLeftNeg = SmartDashboard.getNumber("-IL_Scale",IntakeLeftNeg);
        		IntakeRightPos = SmartDashboard.getNumber("+IR_Scale",IntakeRightPos);
        		IntakeRightNeg = SmartDashboard.getNumber("-IR_Scale",IntakeRightNeg);
        		ArmPos = SmartDashboard.getNumber("+AM_Scale",ArmPos);
        		ArmNeg = SmartDashboard.getNumber("-AM_Scale",ArmNeg);
        		SlidePos = SmartDashboard.getNumber("+SM_Scale",SlidePos);
        		SlideNeg = SmartDashboard.getNumber("-SM_Scale",SlideNeg);
        		
        		
      		//(Front Left Motor Final Value) Displayed on ShuffleBoard Depending on Scaler
      			if(FLSlideVal > 0){
      				FinalFrontLeft = FLSlideVal*FrontLeftPos;
      			}else if(FLSlideVal < 0){
      				FinalFrontLeft = FLSlideVal*FrontLeftNeg;
      			}
     		
      		//(Front Right Motor Final Value) Displayed on ShuffleBoard Depending on Scaler
      			if(FRSlideVal > 0){
      				FinalFrontRight = FRSlideVal*FrontRightPos;
      			}else if(FRSlideVal < 0){
      				FinalFrontRight = FRSlideVal*FrontRightNeg;
      			}
			
      		//(Back Left Motor Final Value) Displayed on ShuffleBoard Depending on Scaler
      			if(BLSlideVal > 0){
      				FinalBackLeft = BLSlideVal*BackLeftPos;
      			}else if(BLSlideVal < 0){
      				FinalBackLeft = BLSlideVal*BackLeftNeg;
      			}
			
      		//(Back Right Motor Final Value) Displayed on ShuffleBoard Depending on Scaler
      			if(BRSlideVal > 0){
      				FinalBackRight = BRSlideVal*BackRightPos;
      			}else if(BRSlideVal < 0){
      				FinalBackRight = BRSlideVal*BackRightNeg;
      			}
      			
      		//(Intake Left Motor Final Value) Displayed on ShuffleBoard Depending on Scaler
      			if(ILSlideVal > 0){
      				FinalIntakeLeft = ILSlideVal*IntakeLeftPos;
      			}else if(ILSlideVal < 0){
      				FinalIntakeLeft = ILSlideVal*IntakeLeftNeg;
      			}
      			
      		//(Intake Right Motor Final Value) Displayed on ShuffleBoard Depending on Scaler
      			if(IRSlideVal > 0){
      				FinalIntakeRight = IRSlideVal*IntakeRightPos;
      			}else if(IRSlideVal < 0){
      				FinalIntakeRight = IRSlideVal*IntakeRightNeg;
      			}
      			
      		//(Arm Motor Final Value) Displayed on ShuffleBoard Depending on Scaler
      			if(AMSlideVal > 0){
      				FinalArm = AMSlideVal*ArmPos;
      			}else if(ILSlideVal < 0){
      				FinalArm = AMSlideVal*ArmNeg;
      			}
      			
      		//(Slide Motor Final Value) Displayed on ShuffleBoard Depending on Scaler
      			if(SMSlideVal > 0){
      				FinalSlide = SMSlideVal*SlidePos;
      			}else if(ILSlideVal < 0){
      				FinalSlide = SMSlideVal*SlideNeg;
      			}
      			
      			
      		//Final Motor Value Output Displayed on Shuffleboard
      			SmartDashboard.putNumber("FLMotor",FinalFrontLeft);
      			SmartDashboard.putNumber("FRMotor",FinalFrontRight);
      			SmartDashboard.putNumber("BLMotor",FinalBackLeft);
      			SmartDashboard.putNumber("BRMotor",FinalBackRight);
      			
      			SmartDashboard.putNumber("ILMotor",FinalIntakeLeft);
      			SmartDashboard.putNumber("IRMotor",FinalIntakeRight);
      			SmartDashboard.putNumber("AMMotor",FinalArm);
      			SmartDashboard.putNumber("SMMotor",FinalSlide);
      	} 
      	
      	
      	
      	
//Controller (Xbox and Joystick) Code is below this line.
      	if(ToggleSliderValue == true) {
      	// Retrieves Scaler set for Drive Train Motors on ShuffleBoard
  			FrontLeftPos = SmartDashboard.getNumber("+FL_Scale",FrontLeftPos);
    		FrontLeftNeg = SmartDashboard.getNumber("-FL_Scale",FrontLeftNeg);
    		FrontRightPos = SmartDashboard.getNumber("+FR_Scale",FrontRightPos);
    		FrontRightNeg = SmartDashboard.getNumber("-FR_Scale",FrontRightNeg);
    		BackLeftPos = SmartDashboard.getNumber("+BL_Scale",BackLeftPos);
    		BackLeftNeg = SmartDashboard.getNumber("-BL_Scale",BackLeftNeg);
    		BackRightPos = SmartDashboard.getNumber("+BR_Scale",BackRightPos);
    		BackRightNeg = SmartDashboard.getNumber("-BR_Scale",BackRightNeg);
 		
    	//Retrieves Intake (Left & Right), Arm Motor, Slide Motor Scalers from ShuffleBoard.
    		IntakeLeftPos = SmartDashboard.getNumber("+IL_Scale",IntakeLeftPos);
    		IntakeLeftNeg = SmartDashboard.getNumber("-IL_Scale",IntakeLeftNeg);
    		IntakeRightPos = SmartDashboard.getNumber("+IR_Scale",IntakeRightPos);
    		IntakeRightNeg = SmartDashboard.getNumber("-IR_Scale",IntakeRightNeg);
    		ArmPos = SmartDashboard.getNumber("+AM_Scale",ArmPos);
    		ArmNeg = SmartDashboard.getNumber("-AM_Scale",ArmNeg);
    		SlidePos = SmartDashboard.getNumber("+SM_Scale",SlidePos);
    		SlideNeg = SmartDashboard.getNumber("-SM_Scale",SlideNeg);
    		      	
      		LeftY2 = Xbox.getY(Hand.kLeft);
	    	RightY2 = Xbox.getY(Hand.kRight);
	    	YAxis = Joystick.getY();
	    	Twist = Joystick.getTwist();
	    	Slider = (-(Joystick.getThrottle()-1)/2);
	    	Trigger = Joystick.getTrigger();
	    	Button = Joystick.getTop();
	    
	    	if(Button==false && Trigger==false){
	        	IntakeLeft.set(0);
	        	FinalIntakeLeft = 0;
	        	IntakeRight.set(0);
	        	FinalIntakeRight = 0;
	        }else if(Button==true && Trigger==false){
	        	IntakeLeft.set(IntakeLeftPos);
	        	FinalIntakeLeft = (IntakeLeftPos);
	        	IntakeRight.set(-IntakeRightNeg);
	        	FinalIntakeRight = (-IntakeRightNeg);
	        }else if(Button==false && Trigger==true){
	        	IntakeLeft.set(-IntakeLeftNeg);
	        	FinalIntakeLeft = (-IntakeLeftNeg);
	        	IntakeRight.set(IntakeRightPos);
	        	FinalIntakeRight = (IntakeRightPos);
	        }//intake motors
	        
	        
	        if(LeftY2<.1 && LeftY2>-.1){
	        	SlideMotor.set(0);
	        	FinalSlide = 0;
	        }else if(LeftY2<.1 && LeftY2<=-.1){
	        	SlideMotor.set(LeftY2*SlideNeg);
	        	FinalSlide = (LeftY2*SlideNeg);
	        }else if(LeftY2>=.1 && LeftY2>-.1){
	        	SlideMotor.set(LeftY2*SlidePos);
	        	FinalSlide = (LeftY2*SlidePos);
	        }//Slide motor
	        
	        if(RightY2<.1 && RightY2>-.1){
	        	ArmMotor.set(0);
	        	FinalArm = 0;
	        }else if(RightY2<.1 && RightY2<=-.1){
	        	ArmMotor.set(RightY2*ArmNeg);
	        	FinalArm = (RightY2*ArmNeg);
	        }else if(RightY2>=.1 && RightY2>-.1){
	        	ArmMotor.set(RightY2*ArmPos);
	        	FinalArm = (RightY2*ArmPos);
	        }//Arm motor
	        
	        
	        if(YAxis<=.1 && YAxis>=-.1 && Twist<=.1 && Twist>=-.1){
	        	FrontLeft.set(0);
	        	FinalFrontLeft = (0);
	        	BackLeft.set(0);
	        	FinalBackLeft = (0);
	        	FrontRight.set(0);
	        	FinalFrontRight = (0);
	        	BackRight.set(0);
	        	FinalFrontRight = (0);
	        	//Idle
	        }else if(YAxis>.1 && Twist<=.1 && Twist>=-.1){
	        	FrontLeft.set((YAxis*FrontLeftNeg)*Slider);
	        	FinalFrontLeft = ((YAxis*FrontLeftNeg)*Slider);
	        	BackLeft.set((YAxis*BackLeftNeg)*Slider);
	        	FinalBackLeft = ((YAxis*BackLeftNeg)*Slider);
	        	FrontRight.set((YAxis*FrontRightNeg)*Slider);
	        	FinalFrontRight = ((YAxis*FrontRightNeg)*Slider);
	        	BackRight.set((YAxis*BackRightNeg)*Slider);
	        	FinalFrontRight = ((YAxis*BackRightNeg)*Slider);
	        	//Motor Back
	        }else if(YAxis<-.1 && Twist<=.1 && Twist>=-.1){
	        	FrontLeft.set((YAxis*FrontLeftPos)*Slider);
	        	FinalFrontLeft = ((YAxis*FrontLeftPos)*Slider);
	        	BackLeft.set((YAxis*BackLeftPos)*Slider);
	        	FinalBackLeft = ((YAxis*BackLeftPos)*Slider);
	        	FrontRight.set((YAxis*FrontRightPos)*Slider);
	        	FinalFrontRight = ((YAxis*FrontRightPos)*Slider);
	        	BackRight.set((YAxis*BackRightPos)*Slider);
	        	FinalFrontRight = ((YAxis*BackRightPos)*Slider);
	        	//Motor Forward
	        }else if(YAxis<-.1 && Twist>.1){
	        	FrontLeft.set((YAxis*FrontLeftPos)*Slider);
	        	FinalFrontLeft = ((YAxis*FrontLeftPos)*Slider);
	        	BackLeft.set((YAxis*BackLeftPos)*Slider);
	        	FinalBackLeft = ((YAxis*BackLeftPos)*Slider);
	        	FrontRight.set(((YAxis*FrontLeftPos)*Slider)*(Twist*FrontLeftPos));
	        	FinalFrontRight = (((YAxis*FrontLeftPos)*Slider)*(Twist*FrontLeftPos));
	        	BackRight.set(((YAxis*BackLeftPos)*Slider)*(Twist*BackLeftPos));
	        	FinalFrontRight = (((YAxis*BackLeftPos)*Slider)*(Twist*BackLeftPos));
	        	//Forward Right
	        }else if(YAxis<-.1 && Twist<-.1){
	        	FrontLeft.set(((YAxis*FrontLeftPos)*Slider)*(Twist*-FrontLeftPos));
	        	FinalFrontLeft = (((YAxis*FrontLeftPos)*Slider)*(Twist*-FrontLeftPos));
	        	BackLeft.set(((YAxis*BackLeftPos)*Slider)*(Twist*-FrontLeftPos));
	        	FinalBackLeft = (((YAxis*BackLeftPos)*Slider)*(Twist*-FrontLeftPos));
	        	FrontRight.set((YAxis*FrontRightPos)*Slider);
	        	FinalFrontRight = ((YAxis*FrontRightPos)*Slider);
	        	BackRight.set((YAxis*BackRightPos)*Slider);
	        	FinalFrontRight = ((YAxis*BackRightPos)*Slider);
	        	//Forward Left
	        }else if(YAxis>.1 && Twist>.1){
	        	FrontLeft.set((YAxis*FrontLeftPos)*Slider);
	        	FinalFrontLeft = ((YAxis*FrontLeftPos)*Slider);
	        	BackLeft.set((YAxis*BackLeftPos)*Slider);
	        	FinalBackLeft = ((YAxis*BackLeftPos)*Slider);
	        	FrontRight.set(((YAxis*FrontLeftPos)*Slider)*(Twist*FrontLeftPos));
	        	FinalFrontRight = (((YAxis*FrontLeftPos)*Slider)*(Twist*FrontLeftPos));
	        	BackRight.set(((YAxis*BackLeftPos)*Slider)*(Twist*BackLeftPos));
	        	FinalFrontRight = (((YAxis*BackLeftPos)*Slider)*(Twist*BackLeftPos));
	        	//Back Right
	        }else if(YAxis>.1 && Twist<-.1){
	        	FrontLeft.set(((YAxis*FrontLeftPos)*Slider)*(Twist*-FrontLeftPos));
	        	FinalFrontLeft = (((YAxis*FrontLeftPos)*Slider)*(Twist*-FrontLeftPos));
	        	BackLeft.set(((YAxis*BackLeftPos)*Slider)*(Twist*-FrontLeftPos));
	        	FinalBackLeft = (((YAxis*BackLeftPos)*Slider)*(Twist*-FrontLeftPos));
	        	FrontRight.set((YAxis*FrontRightPos)*Slider);
	        	FinalFrontRight = ((YAxis*FrontRightPos)*Slider);
	        	BackRight.set((YAxis*BackRightPos)*Slider);
	        	FinalFrontRight = ((YAxis*BackRightPos)*Slider);
	        	//Back Left
	        }else if(YAxis<=.1 && YAxis>=-.1 && Twist<-.1){
	        	FrontLeft.set((Twist*FrontLeftNeg)*Slider);
	        	FinalFrontLeft = ((Twist*FrontLeftNeg)*Slider);
	        	BackLeft.set((Twist*BackLeftNeg)*Slider);
	        	FinalBackLeft = ((Twist*BackLeftNeg)*Slider);
	        	FrontRight.set((Twist*FrontRightPos)*-Slider);
	        	FinalFrontRight = ((Twist*FrontRightPos)*-Slider);
	        	BackRight.set((Twist*BackRightPos)*-Slider);
	        	FinalFrontRight = ((Twist*BackRightPos)*-Slider);
	        	//Spin Left
	        }else if(YAxis<=.1 && YAxis>=-.1 && Twist>.1){
	        	FrontLeft.set((Twist*FrontLeftPos)*Slider);
	        	FinalFrontLeft = ((Twist*FrontLeftPos)*Slider);
	        	BackLeft.set((Twist*BackLeftPos)*Slider);
	        	FinalBackLeft = ((Twist*BackLeftPos)*Slider);
	        	FrontRight.set((Twist*FrontRightNeg)*-Slider);
	        	FinalFrontRight = ((Twist*FrontRightNeg)*-Slider);
	        	BackRight.set((Twist*BackRightNeg)*-Slider);
	        	FinalFrontRight = ((Twist*BackRightNeg)*-Slider);
	        	//Spin Right
	        }      
	    	//Final Motor Value Output Displayed on Shuffleboard (from Controller)
  				SmartDashboard.putNumber("FLMotor",FinalFrontLeft);
  				SmartDashboard.putNumber("FRMotor",FinalFrontRight);
  				SmartDashboard.putNumber("BLMotor",FinalBackLeft);
  				SmartDashboard.putNumber("BRMotor",FinalBackRight);
  			
  				SmartDashboard.putNumber("ILMotor",FinalIntakeLeft);
  				SmartDashboard.putNumber("IRMotor",FinalIntakeRight);
  				SmartDashboard.putNumber("AMMotor",FinalArm);
  				SmartDashboard.putNumber("SMMotor",FinalSlide);
      	}
    }
}
